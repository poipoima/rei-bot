#!/usr/bin/env python3
import os
import sys
import asyncio
import time
import re
import logging
from watchdog.observers import Observer
from watchdog.events import LoggingEventHandler, FileSystemEventHandler
from orator import DatabaseManager, Model
from dotenv import load_dotenv
from bullet import YesNo, Bullet, Input
load_dotenv()

observer = Observer()

config = {
    'mysql': {
        'driver': os.environ.get('db_driver'),
        'host': os.environ.get('db_host'),
        'database': os.environ.get('db_database'),
        'user': os.environ.get('db_user'),
        'password': os.environ.get('db_password'),
        'prefix': ''
    }
}

db = DatabaseManager(config)
Model.set_connection_resolver(db)


def get_file_names(directory_path):
    file_names = []
    for entry in os.listdir(directory_path):
        full_path = os.path.join(directory_path, entry)
        if os.path.isfile(full_path):
            file_names.append(entry)
    
    def extract_number(filename):
        match = re.match(r"^(\d+)", filename)
        return int(match.group(1)) if match else float('inf')

    return sorted(file_names, key=extract_number)

def migrateAll():
    files_in_directory = get_file_names("migrations")

    migratedReader = open(f"migrated", "r")
    migrations = migratedReader.read()
    migratedReader.close()

    migratedAppender = open(f"migrated", "a")

    for file_name in files_in_directory:
        if( "__pycache__" in file_name ):
            continue
        if( ".sql" not in file_name ):
            continue
        if( f"/{file_name}-" in migrations ):
            continue

        codeReader = open(f"migrations/{file_name}", "r")
        code = codeReader.read()
        codeReader.close()

        if( len(code) < 3 ):
            continue
        try:
            db.statement(code)

            migratedAppender.write(f"/{file_name}-\n")

            print(f"+Migration {file_name}")
        except Exception as e:
            print(f"Failed migration {file_name} {e}")


    migratedAppender.close()

def collectFields():
    fields = {}

    while True:
        name = input("Enter variable name (or press Enter to finish): ").strip()
        if not name:
            break
                
        cli = Bullet(
                prompt = f"\nEnter type for '{name}': ",
                choices = ["TINYINT", "INT","BIGINT", "FLOAT", "TEXT", "LONGTEXT", "DATE", "DATETIME", "TIMESTAMP"], 
                indent = 0,
                align = 5, 
                margin = 2,
                shift = 0,
                bullet = "",
                pad_right = 5,
                return_index = False
            )

        result = cli.launch()
        
        fields[name] = result

    return fields

def dict_to_sql_fields(fields: dict) -> str:
    sql_lines = []
    for name, sql_type in fields.items():
        sql_lines.append(f"    {name} {sql_type}")
    return ",\n".join(sql_lines)

def makeMigration(collect=True, fields=None, modelName="", modelRawName=""):
    if fields is None:
        fields = {}

    if collect:
        fields = collectFields()

    if not modelName:
        modelName = input("Migration name: ").capitalize()

    files_in_directory = get_file_names("migrations")

    last_num = int(files_in_directory[-1].split("_")[0]) if files_in_directory else 0

    migrationName = f"migrations/{last_num+1}_{modelName}.sql"

    base_fields = [
        "id BIGINT UNSIGNED AUTO_INCREMENT PRIMARY KEY",
        "created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP",
        "updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP"
    ]

    custom_fields = dict_to_sql_fields(fields)
    all_fields = ",\n".join(base_fields + ([custom_fields] if custom_fields else []))

    content_to_write = f"""-- Created with magi tool
CREATE TABLE {modelName.lower()} (
{all_fields}
);
"""

    try:
        with open(migrationName, "w") as file:
            file.write(content_to_write)
        print(f"+Migration '{modelName}' created successfully.")
    except IOError as e:
        print(f"Error writing to file: {e}")

def makeModel():
    migrationCreation = False
    client = YesNo("Do you want to make a migration? ", default = 'y')

    res = client.launch()
    if( res ):
        migrationCreation = True
    else:
        print("Continuing without migration...")

    modelName = input("Model name ( Singular form ): ").capitalize()


    fields = collectFields()
    makeMigration(False, fields, f"creation_of_table_{modelName.lower()}s", f"{modelName}s")

    fillable_fields = ["id", "created_at", "updated_at"] + list(fields.keys())
    fillable_str = ",\n        ".join([f"'{f}'" for f in fillable_fields])

    modelFile = f"models/{modelName}.py"
    content_to_write = f"""
# Created with magi tool
from orator import DatabaseManager, Model

class {modelName}(Model):
    __fillable__ = [
        {fillable_str}
    ]
    """

    try:
        with open(modelFile, "w") as file:
            file.write(content_to_write)
        print(f"+Model '{modelName}' created successfully.")
    except IOError as e:
        print(f"Error writing to file: {e}")

def makeAddMigration(collect=True, fields=None, modelName="", tableName=""):
    if fields is None:
        fields = {}

    if not modelName:
        modelName = input("Migration name: ").capitalize()

    if not tableName:
        tableName = input("Target table name: ").lower()


    if collect:
        fields = collectFields()

    files_in_directory = get_file_names("migrations")
    last_num = int(files_in_directory[-1].split("_")[0]) if files_in_directory else 0

    migrationName = f"migrations/{last_num+1}_{modelName}.sql"

    alter_lines = []
    for name, sql_type in fields.items():
        alter_lines.append(f"ADD COLUMN {name} {sql_type}")

    alter_sql = ",\n    ".join(alter_lines)

    content_to_write = f"""-- Created with magi tool
ALTER TABLE {tableName}
    {alter_sql};
"""
    try:
        with open(migrationName, "w") as file:
            file.write(content_to_write)
        print(f"+Alter migration '{modelName}' created successfully for table '{tableName}'.")
    except IOError as e:
        print(f"Error writing to file: {e}")


def makeModifyMigration(collect=True, fields=None, modelName="", tableName=""):
    if fields is None:
        fields = {}

    if not modelName:
        modelName = input("Migration name: ").capitalize()

    if not tableName:
        tableName = input("Target table name: ").lower()

    if collect:
        fields = collectFields()

    files_in_directory = get_file_names("migrations")
    last_num = int(files_in_directory[-1].split("_")[0]) if files_in_directory else 0

    migrationName = f"migrations/{last_num+1}_{modelName}.sql"

    modify_lines = []
    for name, sql_type in fields.items():
        modify_lines.append(f"MODIFY COLUMN {name} {sql_type}")

    modify_sql = ",\n    ".join(modify_lines)

    content_to_write = f"""-- Created with magi tool
ALTER TABLE {tableName}
    {modify_sql};
"""
    try:
        with open(migrationName, "w") as file:
            file.write(content_to_write)
        print(f"+Modify migration '{modelName}' created successfully for table '{tableName}'.")
    except IOError as e:
        print(f"Error writing to file: {e}")

def makeDropMigration(collect=True, fields=None, modelName="", tableName=""):
    if fields is None:
        fields = {}

    if not modelName:
        modelName = input("Migration name: ").capitalize()

    if not tableName:
        tableName = input("Target table name: ").lower()

    if collect:
        while True:
            name = input("Enter column name to drop (or press Enter to finish): ").strip()
            if not name:
                break
            fields[name] = None

    files_in_directory = get_file_names("migrations")
    last_num = int(files_in_directory[-1].split("_")[0]) if files_in_directory else 0

    migrationName = f"migrations/{last_num+1}_{modelName}.sql"

    drop_lines = []
    for name in fields.keys():
        drop_lines.append(f"DROP COLUMN {name}")

    drop_sql = ",\n    ".join(drop_lines)

    content_to_write = f"""-- Created with magi tool
ALTER TABLE {tableName}
    {drop_sql};
"""
    try:
        with open(migrationName, "w") as file:
            file.write(content_to_write)
        print(f"+Drop migration '{modelName}' created successfully for table '{tableName}'.")
    except IOError as e:
        print(f"Error writing to file: {e}")


functions = {
    "migrate": migrateAll,
    "migration:make": makeMigration,
    "migration:add": makeAddMigration,
    "migration:modify": makeModifyMigration,
    "migration:remove": makeDropMigration,
    "model:make": makeModel
}

def main():
    if len(sys.argv) < 2:
        print("Usage: pythonscript <argument>")
        return
    
    argument = sys.argv[1]
    if( argument in functions ):
        functions[argument]()


if __name__ == "__main__":
    main()