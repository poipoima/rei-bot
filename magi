#!/usr/bin/env python3
import os
import sys
import asyncio
import time
import re
import logging
from watchdog.observers import Observer
from watchdog.events import LoggingEventHandler, FileSystemEventHandler
from orator import DatabaseManager, Model
from dotenv import load_dotenv
from g4f.client import Client
from bullet import YesNo, Bullet, Input
import eloquentLoader
load_dotenv()

observer = Observer()
aiClient = Client()

aiCommandSlash = """
Generate a simple code that will be put into an @app_commands.command function in discord.py
Command name is $cmd$.
Don't need to generate @app_commands.
but you should generate 
async def PLACEHOLDER(self, interaction: discord.Interaction 'anything user want to be here too or nothing'):
    and further code
always use PLACEHOLDER as a name for a function, do imports only in the function.
DO NOT ADD ANY COMMENTS, do not say anything, do not tell how to use it, return a pure code please.
ONLY CODE, DO NOT TALK.
YOu can use models (orator lib) and include them like
from models.User import User
here's the models list ($models$)
"""

config = {
    'mysql': {
        'driver': os.environ.get('db_driver'),
        'host': os.environ.get('db_host'),
        'database': os.environ.get('db_database'),
        'user': os.environ.get('db_user'),
        'password': os.environ.get('db_password'),
        'prefix': ''
    }
}

db = DatabaseManager(config)
Model.set_connection_resolver(db)


def get_file_names(directory_path):
    file_names = []
    for entry in os.listdir(directory_path):
        full_path = os.path.join(directory_path, entry)
        if os.path.isfile(full_path):
            file_names.append(entry)
    
    def extract_number(filename):
        match = re.match(r"^(\d+)", filename)
        return int(match.group(1)) if match else float('inf')

    return sorted(file_names, key=extract_number)

def migrateAll():
    files_in_directory = get_file_names("migrations")

    migratedReader = open(f"migrated", "r")
    migrations = migratedReader.read()
    migratedReader.close()

    migratedAppender = open(f"migrated", "a")

    for file_name in files_in_directory:
        if( "__pycache__" in file_name ):
            continue
        if( ".sql" not in file_name ):
            continue
        if( f"/{file_name}-" in migrations ):
            continue

        codeReader = open(f"migrations/{file_name}", "r")
        code = codeReader.read()
        codeReader.close()

        if( len(code) < 3 ):
            continue
        try:
            db.statement(code)

            migratedAppender.write(f"/{file_name}-\n")

            print(f"+Migration {file_name}")
        except Exception as e:
            print(f"Failed migration {file_name} {e}")


    migratedAppender.close()

def collectFields():
    fields = {}

    while True:
        name = input("Enter variable name (or press Enter to finish): ").strip()
        if not name:
            break
                
        cli = Bullet(
                prompt = f"\nEnter type for '{name}': ",
                choices = ["TINYINT", "INT","BIGINT", "FLOAT", "TEXT", "LONGTEXT", "DATE", "DATETIME", "TIMESTAMP"], 
                indent = 0,
                align = 5, 
                margin = 2,
                shift = 0,
                bullet = "",
                pad_right = 5,
                return_index = False
            )

        result = cli.launch()
        
        fields[name] = result

    return fields

def dict_to_sql_fields(fields: dict) -> str:
    sql_lines = []
    for name, sql_type in fields.items():
        sql_lines.append(f"    {name} {sql_type}")
    return ",\n".join(sql_lines)

def makeMigration(collect=True, fields=None, modelName="", modelRawName=""):
    if fields is None:
        fields = {}

    if collect:
        fields = collectFields()

    if not modelName:
        modelName = input("Migration name: ").capitalize()

    files_in_directory = get_file_names("migrations")

    last_num = int(files_in_directory[-1].split("_")[0]) if files_in_directory else 0

    migrationName = f"migrations/{last_num+1}_{modelName}.sql"

    base_fields = [
        "id BIGINT UNSIGNED AUTO_INCREMENT PRIMARY KEY",
        "created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP",
        "updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP"
    ]

    custom_fields = dict_to_sql_fields(fields)
    all_fields = ",\n".join(base_fields + ([custom_fields] if custom_fields else []))

    content_to_write = f"""-- Created with magi tool
CREATE TABLE {modelName.lower()} (
{all_fields}
);
"""

    try:
        with open(migrationName, "w") as file:
            file.write(content_to_write)
        print(f"+Migration '{modelName}' created successfully.")
    except IOError as e:
        print(f"Error writing to file: {e}")

def makeModel():
    migrationCreation = False
    client = YesNo("Do you want to make a migration? ", default = 'y')

    res = client.launch()
    if( res ):
        migrationCreation = True
    else:
        print("Continuing without migration...")

    modelName = input("Model name ( Singular form ): ").capitalize()


    fields = collectFields()
    makeMigration(False, fields, f"creation_of_table_{modelName.lower()}s", f"{modelName}s")

    fillable_fields = ["id", "created_at", "updated_at"] + list(fields.keys())
    fillable_str = ",\n        ".join([f"'{f}'" for f in fillable_fields])

    modelFile = f"models/{modelName}.py"
    content_to_write = f"""
# Created with magi tool
from orator import DatabaseManager, Model

class {modelName}(Model):
    __fillable__ = [
        {fillable_str}
    ]
    """

    try:
        with open(modelFile, "w") as file:
            file.write(content_to_write)
        print(f"+Model '{modelName}' created successfully.")
    except IOError as e:
        print(f"Error writing to file: {e}")

def makeAddMigration(collect=True, fields=None, modelName="", tableName=""):
    if fields is None:
        fields = {}

    if not modelName:
        modelName = input("Migration name: ").capitalize()

    if not tableName:
        tableName = input("Target table name: ").lower()


    if collect:
        fields = collectFields()

    files_in_directory = get_file_names("migrations")
    last_num = int(files_in_directory[-1].split("_")[0]) if files_in_directory else 0

    migrationName = f"migrations/{last_num+1}_{modelName}.sql"

    alter_lines = []
    for name, sql_type in fields.items():
        alter_lines.append(f"ADD COLUMN {name} {sql_type}")

    alter_sql = ",\n    ".join(alter_lines)

    content_to_write = f"""-- Created with magi tool
ALTER TABLE {tableName}
    {alter_sql};
"""
    try:
        with open(migrationName, "w") as file:
            file.write(content_to_write)
        print(f"+Alter migration '{modelName}' created successfully for table '{tableName}'.")
    except IOError as e:
        print(f"Error writing to file: {e}")


def makeModifyMigration(collect=True, fields=None, modelName="", tableName=""):
    if fields is None:
        fields = {}

    if not modelName:
        modelName = input("Migration name: ").capitalize()

    if not tableName:
        tableName = input("Target table name: ").lower()

    if collect:
        fields = collectFields()

    files_in_directory = get_file_names("migrations")
    last_num = int(files_in_directory[-1].split("_")[0]) if files_in_directory else 0

    migrationName = f"migrations/{last_num+1}_{modelName}.sql"

    modify_lines = []
    for name, sql_type in fields.items():
        modify_lines.append(f"MODIFY COLUMN {name} {sql_type}")

    modify_sql = ",\n    ".join(modify_lines)

    content_to_write = f"""-- Created with magi tool
ALTER TABLE {tableName}
    {modify_sql};
"""
    try:
        with open(migrationName, "w") as file:
            file.write(content_to_write)
        print(f"+Modify migration '{modelName}' created successfully for table '{tableName}'.")
    except IOError as e:
        print(f"Error writing to file: {e}")

def makeDropMigration(collect=True, fields=None, modelName="", tableName=""):
    if fields is None:
        fields = {}

    if not modelName:
        modelName = input("Migration name: ").capitalize()

    if not tableName:
        tableName = input("Target table name: ").lower()

    if collect:
        while True:
            name = input("Enter column name to drop (or press Enter to finish): ").strip()
            if not name:
                break
            fields[name] = None

    files_in_directory = get_file_names("migrations")
    last_num = int(files_in_directory[-1].split("_")[0]) if files_in_directory else 0

    migrationName = f"migrations/{last_num+1}_{modelName}.sql"

    drop_lines = []
    for name in fields.keys():
        drop_lines.append(f"DROP COLUMN {name}")

    drop_sql = ",\n    ".join(drop_lines)

    content_to_write = f"""-- Created with magi tool
ALTER TABLE {tableName}
    {drop_sql};
"""
    try:
        with open(migrationName, "w") as file:
            file.write(content_to_write)
        print(f"+Drop migration '{modelName}' created successfully for table '{tableName}'.")
    except IOError as e:
        print(f"Error writing to file: {e}")

from bullet import Bullet
import os


def collectCommands():
    commands_list = []

    while True:
        name = input("Enter command name (or press Enter to finish): ").strip()
        if not name:
            break

        description = input(f"Enter description for '{name}': ").strip() or "No description provided."

        cli = Bullet(
            prompt=f"\nSelect command type for '{name}': ",
            choices=["slash (app_commands)", "classic (!command)"],
            indent=0,
            align=5,
            margin=2,
            shift=0,
            bullet="â†’",
            pad_right=5,
            return_index=False
        )

        cmd_type = cli.launch()

        commands_list.append({
            "name": name,
            "description": description,
            "type": cmd_type
        })

    return commands_list


def makeCog():
    cogName = input("Cog name ( Singular form ): ").strip()
    cogNameC = cogName.capitalize()

    cli = Bullet(
        prompt="\nSelect Cog type: ",
        choices=["Normal Cog", "Group Cog (for slash commands)"],
        bullet="â†’",
        pad_right=5
    )
    cog_type = cli.launch()

    commands_list = collectCommands()

    cogNamePath = f"cogs/{cogName.lower()}.py"
    os.makedirs("cogs", exist_ok=True)

    command_defs = []
    for cmd in commands_list:
        if cmd["type"].startswith("slash"):
            client = YesNo(f"Do you want to generate a basic code with AI for {cmd['name']}? ", default = 'n')
            res = client.launch()
            
            if( res ):
                whatYoutWant = input( "What the command should do?\n" )

                modelsList = ", ".join( eloquentLoader.getModelsList() )
                
                history = []
                history.append({"role": "user", "content": whatYoutWant})
                history.insert(0, {"role": "system", "content": aiCommandSlash.replace("$cmd$",cmd['name']).replace("$models$",modelsList)})

                response = aiClient.chat.completions.create(
                    model="gpt-4",
                    messages=history,
                    web_search=False
                )

                command_defs.append(f"""
    @app_commands.command(name="{cmd['name']}", description="{cmd['description']}")
    {response.choices[0].message.content.replace("PLACEHOLDER",cmd['name']).replace("```python","").replace("```","").replace("\n\n","\n").replace("\n","\n    ")}""")
            else:
                command_defs.append(f"""
    @app_commands.command(name="{cmd['name']}", description="{cmd['description']}")
    async def {cmd['name']}(self, interaction: discord.Interaction):
        await interaction.response.send_message("Executed /{cmd['name']}!")""")
        else:
            command_defs.append(f"""
    @commands.command(name="{cmd['name']}", help="{cmd['description']}")
    async def {cmd['name']}(self, ctx: commands.Context):
        await ctx.send("Executed !{cmd['name']}!")""")

    command_defs_str = "\n".join(command_defs)

    if cog_type.startswith("Group"):
        content_to_write = f"""# Created with magi tool
import discord
from discord.ext import commands
from discord import app_commands

class {cogNameC}(commands.GroupCog, name="{cogName.lower()}", description="{cogName.lower()} commands"):
    def __init__(self, bot):
        self.bot = bot
{command_defs_str}

"""
    else:
        content_to_write = f"""# Created with magi tool
import discord
from discord.ext import commands
from discord import app_commands

class {cogNameC}(commands.Cog):
    def __init__(self, bot):
        self.bot = bot
{command_defs_str}

"""

    try:
        with open(cogNamePath, "w") as file:
            file.write(content_to_write)
        print(f"+Cog '{cogNameC}' created successfully with {len(commands_list)} command(s). Type: {cog_type}")
    except IOError as e:
        print(f"Error writing to file: {e}")


functions = {
    "migrate": migrateAll,
    "migration:make": makeMigration,
    "migration:add": makeAddMigration,
    "migration:modify": makeModifyMigration,
    "migration:remove": makeDropMigration,
    "model:make": makeModel,
    "cog:make": makeCog,
}

def main():
    if len(sys.argv) < 2:
        print("Usage: pythonscript <argument>")
        return
    
    argument = sys.argv[1]
    if( argument in functions ):
        functions[argument]()


if __name__ == "__main__":
    main()